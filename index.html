<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Spider</title>
  <style>
    :root{
      --bg1:#0b1220; --bg2:#102338; --feather:#0ea5e9; --accent:#22d3ee; --accent2:#7c3aed; --ok:#22c55e; --warn:#f59e0b; --muted:#9fb2c7; --text:#e6eef7;
      --panel:rgba(13,22,37,.6); --border:rgba(255,255,255,.14); --shadow:0 20px 50px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:
      radial-gradient(900px 600px at 10% 0%, rgba(124,58,237,.12), transparent 60%),
      radial-gradient(900px 600px at 90% 100%, rgba(14,165,233,.12), transparent 60%),
      linear-gradient(180deg,var(--bg1),var(--bg2));
      color:var(--text);
      overflow:hidden;
    }
    #hud {
      position: fixed;
      left: 16px;
      right: 16px;
      top: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
      font-size: 1.5em;
    }
    
    #top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 8px 15px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    
    #menu-bar {
      position: fixed;
      left: 16px;
      top: 100px;
      width: 170px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 10;
    }
    
    .card {
      display: flex;
      gap: 8px;
      align-items: center;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 8px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
    }
    button,select,input[type="text"]{appearance:none;border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--text);padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer; font-size: 1.125em;}
    button:hover{transform:translateY(-1px)}
    button:disabled{opacity:.5;cursor:not-allowed}
    .pill{padding:9px 15px;border-radius:999px;border:1px dashed var(--border);font-size:18px;color:var(--muted)}
    #status{position:fixed;left:16px;right:16px;bottom:12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap;z-index:10}
    #game{position:fixed;left:186px;right:0;top:0;bottom:0;overflow:hidden}
    #difficulty{ margin:0 8px; padding:2px 4px; border-radius:4px; border:1px solid #666; background:#222; color:#fff; }
    .aces-toggle { display: inline-flex; align-items: center; margin: 0 8px; cursor: pointer; user-select: none; }
    .aces-toggle input { margin-right: 4px; }
    .aces-toggle:hover { color: #ffd700; }
    #seedInput{ width:100px; margin:0 8px; padding:2px 4px; border-radius:4px; border:1px solid #666; background:#222; color:#fff; }
    .kbd{padding:2px 8px;border-radius:6px;border:1px solid var(--border);background:rgba(255,255,255,.06);font-size:12px}
    .win{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;place-items:center;z-index:20}
    .win .modal-content { background:#2a2a2a; padding:24px; border-radius:12px; max-width:90%; max-height:90%; overflow-y:auto; position:relative; box-shadow:0 4px 20px rgba(0,0,0,0.3); }
    .modal h2 { margin-top:0; color:#fff; text-align:center; }
    .modal h3 { color:#ddd; margin: 16px 0 12px; font-size: 1.2em; }
    
    /* Stats container */
    .stats-container { display: flex; flex-direction: column; gap: 24px; }
    .stats-section { background: rgba(255,255,255,0.05); padding: 16px; border-radius: 8px; }
    
    /* Stats grid */
    .stats-grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 12px; 
      margin-top: 12px;
    }
    .stat-item {
      background: rgba(255,255,255,0.1);
      padding: 12px;
      border-radius: 6px;
      font-size: 0.95em;
    }
    .stat-label {
      font-weight: bold;
      color: #fff;
      margin-right: 8px;
    }
    
    /* Recent games */
    .recent-games {
      max-height: 300px;
      overflow-y: auto;
      margin-top: 12px;
    }
    .game-record {
      background: rgba(255,255,255,0.1);
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 8px;
      font-size: 0.9em;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .game-record.win { border-left: 4px solid #4CAF50; }
    .game-record.loss { border-left: 4px solid #f44336; }
    .game-record.abandoned { border-left: 4px solid #ff9800; }
    .game-record .game-outcome {
      font-weight: bold;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.8em;
    }
    .game-record.win .game-outcome { background: rgba(76, 175, 80, 0.2); color: #4CAF50; }
    .game-record.loss .game-outcome { background: rgba(244, 67, 54, 0.2); color: #f44336; }
    .game-record.abandoned .game-outcome { background: rgba(255, 152, 0, 0.2); color: #ff9800; }
    .game-record .game-details {
      display: flex;
      gap: 16px;
      font-size: 0.9em;
      color: #bbb;
    }
    .game-record .game-time {
      font-family: monospace;
    }
    .row{display:flex;gap:10px;justify-content:center;margin-top:14px}
    .seedbox{width:160px}
    .hint-list {
      max-height: 60vh;
      overflow-y: auto;
      margin: 15px 0;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
    }
    
    .hint-item {
      padding: 10px;
      margin: 5px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .hint-item:hover {
      background: rgba(34, 211, 238, 0.2);
    }
    
    .hint-item.best {
      border-left: 4px solid #22d3ee;
      background: rgba(34, 211, 238, 0.15);
    }
    
    .hint-details {
      font-size: 0.9em;
      color: #9fb2c7;
      margin-top: 3px;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 20px;
      box-sizing: border-box;
    }
    
    .modal-content {
      background: var(--bg1);
      border-radius: 12px;
      padding: 24px;
      max-width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
    }
    
    .stats-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    
    .stats-section {
      flex: 1;
      min-width: 300px;
      background: var(--panel);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    
    .recent-games {
      margin-top: 12px;
    }
    
    .recent-game {
      background: rgba(255,255,255,0.05);
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 8px;
      border: 1px solid var(--border);
    }
    
    .recent-game div {
      margin: 4px 0;
    }
    
    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      margin-top: 20px;
    }
    
    .modal-buttons button {
      padding: 8px 16px;
      border-radius: 4px;
      border: none;
      background: var(--accent);
      color: white;
      cursor: pointer;
    }
    
    .modal-buttons button:hover {
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div id="top-bar">
      <div style="display: flex; gap: 15px; align-items: center;">
        <div>David's Spider - v0.0.3</div>
        <div>Time: <span id="time">0:00</span></div>
        <div>Moves: <span id="moves">0</span></div>
        <div>Score: <span id="score">500</span></div>
        <div>Deals: <span id="deals">5</span></div>
        <div style="color: #22c55e; font-weight: 600;">Sets: <span id="sets-counter" style="color: white;">0</span></div>
        <div class="pill">Seed: <span id="seedLabel"></span></div>
      </div>
      <button id="showStats">📊 Stats</button>
    </div>
  </div>
  
  <div id="menu-bar">
    <div class="card" style="padding: 8px; display: flex; flex-direction: column; gap: 4px;">
      <button id="newBtn" title="N" style="width: 100%; text-align: left;">New Game</button>
      <button id="replayBtn" title="Replay seed" style="width: 100%; text-align: left;">Replay</button>
      <button id="undoBtn" title="U" style="width: 100%; text-align: left;">Undo</button>
      <button id="redoBtn" title="R" style="width: 100%; text-align: left;">Redo</button>
      <button id="hintBtn" title="H" style="width: 100%; text-align: left;">Hint</button>
      <button id="dealBtn" title="D" style="width: 100%; text-align: left; margin-bottom: 8px;">Deal</button>
      
      <select id="difficulty" style="width: 100%; margin-bottom: 8px; padding: 6px; font-size: 0.9em;">
        <option value="1-suit" selected>1-suit</option>
        <option value="2-suit">2-suit</option>
        <option value="4-suit">4-suit</option>
      </select>
      
      <label style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-size: 0.9em;">
        <input type="checkbox" id="includeAces">
        <span>Include Aces</span>
      </label>
      
      <div style="display: flex; gap: 4px; margin-bottom: 8px;">
        <input id="seedInput" type="text" placeholder="custom seed" style="flex: 1; padding: 6px; font-size: 0.9em;"/>
        <button id="setSeedBtn" style="padding: 0 8px;">Set</button>
      </div>
      
      <div style="display: flex; gap: 4px;">
        <button id="muteBtn" style="flex: 1; padding: 6px;">🔊</button>
        <button id="verifyBtn" title="Check deck & invariants" style="flex: 1; padding: 6px;">Verify</button>
      </div>
    </div>
    <span id="dealReason" class="pill" style="display:none; margin-top: 6px; text-align: center; font-size: 0.9em;"></span>
  </div>

  <canvas id="game"></canvas>

  <div id="status"><span class="pill" id="msg"></span></div>

  <div id="winModal" class="modal">
    <div class="modal-content">
      <h2>🦚 You Win!</h2>
      <div>Time <b id="winTime">0:00</b> • Moves <b id="winMoves">0</b> • Score <b id="winScore">0</b></div>
      <div class="modal-buttons">
        <button id="playAgain">Play again</button>
        <button id="shareSeed">Copy share link</button>
      </div>
    </div>
  </div>
  
  <div id="hintModal" class="modal">
    <div class="modal-content">
      <h2>💡 Available Moves</h2>
      <div id="hintList" class="hint-list"></div>
      <div class="modal-buttons">
        <button id="closeHint">Close</button>
      </div>
    </div>
  </div>

  <!-- Statistics Modal -->
  <div id="statsModal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
      <h2>📊 Game Statistics</h2>
      <div class="stats-container">
        <div class="stats-section">
          <h3>Overall Statistics</h3>
          <div id="overallStats" class="stats-grid"></div>
        </div>
        <div class="stats-section">
          <h3>Recent Games</h3>
          <div id="recentGames" class="recent-games"></div>
        </div>
      </div>
      <div class="modal-buttons">
        <button id="closeStats">Close</button>
      </div>
    </div>
  </div>

  <!-- Game Statistics Module -->
  <script type="module" src="./stats.js"></script>
  
  <script type="module">
    // Import stats module
    import { trackGameStart, updateActiveGame, recordGameResult, recoverIncompleteGames, getGameStats } from './stats.js';
    
    // =============================
    // Spider Solitaire v 0.0.2
    // - Added game statistics tracking
    // - Added auto-save and recovery
    // =============================
    const $ = (id)=>document.getElementById(id);
    const clamp=(v,a,b)=>v<a?a:v>b?b:v;
    const now = ()=>performance.now();
    const RED = new Set(['♥','♦']);

    // ---------- PRNG ----------
    function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t ^ t>>>15, t|1); t^=t+Math.imul(t ^ t>>>7, t|61); return ((t ^ t>>>14)>>>0)/4294967296; } }
    function hashSeed(str){ let h=2166136261>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0; }
    function shuffle(arr, rnd){ for(let i=arr.length-1;i>0;i--){ const j=(rnd()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; } }
    const randSeed = ()=>{ const a=new Uint32Array(2); crypto.getRandomValues(a); return (a[0].toString(36)+a[1].toString(36)).slice(0,10); };

    // ---------- Sounds (WebAudio) ----------
    const AudioKit = (()=>{ 
      const ctx = new (window.AudioContext||window.webkitAudioContext)(); 
      let muted = localStorage.getItem('audioMuted') === 'true' || false;
      
      // Play a triumphant fanfare sound for foundation completion (one octave lower)
      const playFanfare = () => {
        if (muted) return;
        const now = ctx.currentTime;
        const osc1 = ctx.createOscillator();
        const osc2 = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc1.type = 'sine';
        osc2.type = 'sine';
        // Lowered frequencies by one octave (half the original frequencies)
        osc1.frequency.setValueAtTime(440, now);   // Was 880 (A5), now A4
        osc2.frequency.setValueAtTime(554.365, now); // Was ~1109 (C#6), now C#5
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.15, now + 0.1);
        gain.gain.linearRampToValueAtTime(0, now + 1.2);
        
        osc1.connect(gain);
        osc2.connect(gain);
        gain.connect(ctx.destination);
        
        osc1.start(now);
        osc2.start(now);
        osc1.stop(now + 1.2);
        osc2.stop(now + 1.2);
      };
      
      // Play a card shuffle sound
      const playShuffle = () => {
        if (muted) return;
        const now = ctx.currentTime;
        const bufferSize = ctx.sampleRate * 0.5; // 0.5 seconds of audio
        const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        
        // Generate white noise
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        
        // Create a bandpass filter to make it sound more like cards
        const bandpass = ctx.createBiquadFilter();
        bandpass.type = 'bandpass';
        bandpass.frequency.value = 800;
        bandpass.Q.value = 1.0;
        
        // Create a lowpass filter to soften the sound
        const lowpass = ctx.createBiquadFilter();
        lowpass.type = 'lowpass';
        lowpass.frequency.value = 2000;
        
        // Create gain envelope
        const gainNode = ctx.createGain();
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        
        // Connect nodes
        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuffer;
        noise.connect(bandpass);
        bandpass.connect(lowpass);
        lowpass.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        // Play with slight variations
        for (let i = 0; i < 3; i++) {
          const startTime = now + (i * 0.12);
          noise.start(startTime);
          noise.stop(startTime + 0.5);
        }
      };
      
      // Base sound generator
      function generateSound(freq=880, len=0.06, type='triangle', gain=0.05, click=false) { 
        if (muted) return null;
        
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = type;
        o.frequency.value = freq;
        o.connect(g);
        
        // For click sound, create a sharp attack
        if (click) {
          g.gain.setValueAtTime(0, ctx.currentTime);
          g.gain.linearRampToValueAtTime(gain, ctx.currentTime + 0.001);
          g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + len);
        } else {
          g.gain.value = gain;
          g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + len);
        }
        
        g.connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + len);
        return o;
      };
      
      // Sound effects
      function blip(freq=880, len=0.06, type='triangle', gain=0.05) { 
        generateSound(freq, len, type, gain);
      }
      
      function click() {
        generateSound(1000, 0.04, 'sine', 0.2, true);
      }
      
      function thud() {
        generateSound(100, 0.3, 'sine', 0.8);  // Increased gain from 0.3 to 0.5
      }
      
      function chord() { 
        if (muted) return; 
        [523, 659, 784, 988].forEach((f, i) => 
          setTimeout(() => generateSound(f, 0.16, 'sine', 0.06), i * 70)
        );
      }
      
      function setMuted(v) {
        muted = v;
        localStorage.setItem('audioMuted', v);
        // Update button text if it exists
        const muteBtn = document.getElementById('muteBtn');
        if (muteBtn) {
          muteBtn.textContent = v ? '🔇' : '🔊';
        }
      }
      
      return { 
        blip, 
        click,
        thud,
        chord, 
        setMuted, 
        isMuted: () => muted, 
        resume() { 
          if (ctx.state === 'suspended') {
            ctx.resume();
          }
        },
        fanfare: playFanfare,
        shuffle: playShuffle
      };
    })();

    // ---------- Engine State ----------
    const state = {
      difficulty:'1-suit', seed:'', rng:null, includeAces: false,
      tableau:[[],[],[],[],[],[],[],[],[],[]], stock:[], dealsRemaining:5, foundations:0,
      moves:0, score:500, startTime:0, elapsedMs:0, running:true,
      history:[], redo:[], message:'', hint:null, won:false, foundationsCards:[]
    };

    function createDeck(difficulty, includeAces = false){
      let suits;
      if(difficulty==='1-suit') suits=Array(8).fill('♠');
      else if(difficulty==='2-suit') suits=[...Array(4).fill('♠'), ...Array(4).fill('♥')];
      else suits=['♠','♥','♦','♣','♠','♥','♦','♣'];
      const deck=[]; let id=0; 
      const minRank = includeAces ? 1 : 2; // Start from Ace (1) or 2 based on setting
      for(const s of suits){ 
        for(let r=minRank;r<=13;r++){ 
          deck.push({id:id++, suit:s, rank:r, faceUp:false}); 
        } 
      }
      return deck;
    }

    function initialDeal(deck){ const cols=Array.from({length:10},()=>[]); let idx=0; for(let pass=0;pass<6;pass++){ for(let c=0;c<10;c++){ if(pass===5 && c>=4) continue; const card=deck[idx++]; cols[c].push(card); } } for(let c=0;c<10;c++){ cols[c][cols[c].length-1].faceUp=true; } const stock=deck.slice(idx); return {tableau:cols, stock}; }

    const top = (col)=>col[col.length-1];

    function canDrop(tailHead, destTop){ if(!destTop) return true; return tailHead.rank+1===destTop.rank; }

    function tryComplete(col, includeAces = false){ 
      const minRank = includeAces ? 1 : 2;
      const expectedLength = 14 - minRank; // 13 for Aces included, 12 for Aces excluded
      if(col.length < expectedLength) return null; 
      const L = col.length;
      const suit = col[L-1].suit; 
      for(let i=0; i<expectedLength; i++){ 
        const card = col[L-1-i]; 
        if(!(card.faceUp && card.suit === suit && card.rank === (minRank + i))) 
          return null; 
      } 
      return col.splice(L-expectedLength, expectedLength);
    }

    function removeFromFoundations(cards){
      const set = new Set(cards.map(c=>c.id));
      state.foundationsCards = state.foundationsCards.filter(c=>!set.has(c.id));
    }

    function completeTopRun(colIndex, includeAces = false){
      const col = state.tableau[colIndex];
      const rem = tryComplete(col, includeAces);
      if(!rem) return false;
      let turned = null;
      if(col.length && !top(col).faceUp){
        top(col).faceUp = true;
        turned = top(col);
      }
      state.foundationsCards.push(...rem);
      state.foundations++;
      state.history.push({t:'complete', col:colIndex, cards:rem, turned});
      state.score += 100;
      AudioKit.fanfare();
      return true;
    }

    // ---------- Game actions ----------
    function newGame({difficulty=state.difficulty, seed=randSeed(), includeAces=state.includeAces}={}){
      // Track the new game in statistics
      const suitCount = difficulty === '1-suit' ? 1 : difficulty === '2-suit' ? 2 : 4;
      trackGameStart({ suitCount, seed, difficulty });
      
      state.difficulty=difficulty; 
      state.seed=seed; 
      state.includeAces = includeAces;
      state.rng=mulberry32(hashSeed(difficulty+':'+seed));
      const deck=createDeck(difficulty, includeAces); 
      shuffle(deck, state.rng);
      const deal=initialDeal(deck);
      state.tableau=deal.tableau; state.stock=deal.stock; state.dealsRemaining=5; state.foundations=0;
      state.moves=0; state.score=500; state.history=[]; state.redo=[]; state.message=''; state.hint=null; state.won=false;
      state.startTime=now(); state.elapsedMs=0; state.running=true; updateUI(); draw();
      
      // Reset and start the timer
      lastTick = now();
      tick();
      saveGame();
    }

    function dealRow(){ 
      if(state.dealsRemaining<=0 && state.stock.length > 0){ flashMsg('No deals left'); return false; }
      for(let c=0;c<10;c++){ if(state.tableau[c].length===0){ flashMsg('Fill empty columns before dealing'); return false; } }
      
      const dealt=[];
      const cardsToDeal = Math.min(state.stock.length, 10);
      
      // If this is the final deal with remaining cards, allow it even with no deals remaining
      const isFinalDeal = state.dealsRemaining === 1 && state.stock.length > 0 && state.stock.length < 10;
      
      if (isFinalDeal) {
        // For the final deal, distribute remaining cards to the first N columns
        for(let c=0; c<state.stock.length; c++) {
          const card = state.stock.shift();
          card.faceUp = true;
          state.tableau[c].push(card);
          dealt.push(card);
        }
        state.dealsRemaining = 0; // No more deals after this
      } else {
        // Normal deal - 10 cards or remaining cards if less than 10
        for(let c=0; c<cardsToDeal; c++){
          const card = state.stock.shift();
          if(card) {
            card.faceUp = true;
            state.tableau[c].push(card);
            dealt.push(card);
          }
        }
        
        // Only decrement deals if we actually dealt a full row (10 cards)
        if (cardsToDeal === 10) {
          state.dealsRemaining--;
        }
      }
      state.history.push({t:'deal', dealt});
      state.redo=[];
      state.moves++;
      state.score=Math.max(0,state.score-1);
      
      // Update active game stats
      updateActiveGame({
        moves: state.moves,
        score: state.score,
        lastMove: new Date().toISOString()
      });
      
      // Check for completion after dealing
      for(let c=0;c<10;c++){
        completeTopRun(c, state.includeAces);
      }
      
      updateUI();
      draw();
      saveGame();
      AudioKit.shuffle();
      
      return true;
    }

    function doMove(from, startIndex, to){ 
      if(from===to) return false; 
      const src=state.tableau[from], dst=state.tableau[to]; 
      const n=src.length; 
      if(startIndex<0||startIndex>=n) return false; 
      // validate same-suit descending from startIndex..end
      for(let i=n-1;i>startIndex;i--){ 
        const a=src[i], b=src[i-1]; 
        if(!(a.faceUp && b.faceUp && a.rank+1===b.rank && a.suit===b.suit)){ 
          bounce(); 
          flashMsg('Select a same-suit descending tail'); 
          return false; 
        } 
      }
      const moved=src.slice(startIndex); 
      if(!canDrop(moved[0], top(dst))){ 
        bounce(); 
        flashMsg('Illegal move'); 
        return false; 
      }
      dst.push(...moved); 
      src.length=startIndex; 
      let turned=null; 
      if(src.length && !top(src).faceUp){ 
        top(src).faceUp=true; 
        turned=top(src); 
      }
      state.history.push({t:'move', from, to, moved:structuredClone(moved), turned}); 
      state.redo=[]; 
      state.moves++; 
      state.score=Math.max(0,state.score-1); 
      
      // Update active game stats
      updateActiveGame({
        moves: state.moves,
        score: state.score,
        lastMove: new Date().toISOString()
      });
      
      // try completes on both piles
      completeTopRun(to);
      completeTopRun(from);
      checkWin(); 
      updateUI(); 
      draw(); 
      saveGame(); 
      return true; 
    }

    function undo(){ 
      const h=state.history.pop(); 
      if(!h) return;
      
      if(h.t==='complete'){
        const col=state.tableau[h.col];
        col.push(...h.cards);
        if(h.turned){
          const idx=col.findIndex(c=>c.id===h.turned.id);
          if(idx>=0) col[idx].faceUp=false;
        }
        removeFromFoundations(h.cards);
        state.foundations--;
        state.score -= 100;
        state.redo.push(h);
      }
      else if(h.t==='move'){
        const colFrom=state.tableau[h.from], colTo=state.tableau[h.to];
        const k=h.moved.length;
        colTo.splice(colTo.length-k,k);
        colFrom.push(...h.moved);
        if(h.turned){
          const idx=colFrom.findIndex(c=>c.id===h.turned.id);
          if(idx>=0) colFrom[idx].faceUp=false;
        }
        state.redo.push(h);
      }
      else if(h.t==='deal'){
        for(let i=9;i>=0;i--){
          const card=state.tableau[i].pop();
          card.faceUp=false;
          state.stock.unshift(card);
        }
        state.dealsRemaining++;
        state.redo.push(h);
      }
      
      state.moves++;
      
      // Update active game stats after undo
      updateActiveGame({
        moves: state.moves,
        score: state.score,
        foundations: state.foundations,
        lastMove: new Date().toISOString()
      });
      
      draw();
      updateUI();
      saveGame();
    }

    function redo(){ 
      const h=state.redo.pop(); 
      if(!h) return;
      
      if(h.t==='complete'){
        const col=state.tableau[h.col];
        col.splice(col.length-13,13);
        if(h.turned){
          const idx=col.findIndex(c=>c.id===h.turned.id);
          if(idx>=0) col[idx].faceUp=true;
        }
        state.foundationsCards.push(...h.cards);
        state.foundations++;
        state.score += 100;
        state.history.push(h);
      }
      else if(h.t==='move'){
        const colFrom=state.tableau[h.from], colTo=state.tableau[h.to];
        colFrom.splice(colFrom.length-h.moved.length, h.moved.length);
        colTo.push(...h.moved);
        if(h.turned){
          const idx=colFrom.findIndex(c=>c.id===h.turned.id);
          if(idx>=0) colFrom[idx].faceUp=true;
        }
        state.history.push(h);
      }
      else if(h.t==='deal'){
        for(let c=0;c<10;c++){
          const card=state.stock.shift();
          card.faceUp=true;
          state.tableau[c].push(card);
        }
        state.dealsRemaining--;
        state.history.push(h);
      }
      
      state.moves++;
      
      // Update active game stats after redo
      updateActiveGame({
        moves: state.moves,
        score: state.score,
        foundations: state.foundations,
        lastMove: new Date().toISOString()
      });
      
      draw();
      updateUI();
      saveGame();
    }

    function checkWin(){ 
      if(state.foundations===8){ 
        state.won=true; 
        state.running=false; 
        AudioKit.chord(); 
        recordGameResult('win');
        showWin(); 
      } 
    }

    // ---------- Persistence ----------
    const STORAGE_KEY='spider.v2.lastGame';
    
    // Check for incomplete game on load
    window.addEventListener('load', async () => {
      try {
        const incompleteGame = await recoverIncompleteGames();
        if (incompleteGame) {
          // Mark any incomplete game as abandoned without showing a popup
          recordGameResult('abandoned');
        }
      } catch {
        // Silently handle any errors during game recovery
      }
    });
    function saveGame(){
      try{
        const payload={
          d:state.difficulty, s:state.seed, deals:state.dealsRemaining, f:state.foundations, m:state.moves, sc:state.score, t:state.elapsedMs,
          tab:state.tableau.map(col=>col.map(c=>({id:c.id,s:c.suit,r:c.rank,u:c.faceUp}))),
          stock:state.stock.map(c=>({id:c.id,s:c.suit,r:c.rank,u:c.faceUp})),
          fd:state.foundationsCards.map(c=>({id:c.id,s:c.suit,r:c.rank,u:c.faceUp}))
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      }catch{}
    }
    function loadGame(){
      try{
        const raw=localStorage.getItem(STORAGE_KEY); if(!raw) return false; const p=JSON.parse(raw);
        state.difficulty=p.d; state.seed=p.s; state.rng=mulberry32(hashSeed(state.difficulty+':'+state.seed));
        state.dealsRemaining=p.deals; state.foundations=p.f; state.moves=p.m; state.score=p.sc; state.elapsedMs=p.t; state.running=true; state.won=false; state.history=[]; state.redo=[];
        state.tableau=p.tab.map(col=>col.map(o=>({id:o.id,suit:o.s,rank:o.r,faceUp:o.u})));
        state.stock=p.stock.map(o=>({id:o.id,suit:o.s,rank:o.r,faceUp:o.u}));
        state.foundationsCards=(p.fd||[]).map(o=>({id:o.id,suit:o.s,rank:o.r,faceUp:o.u}));
        updateUI(); draw(); return true;
      }catch{ return false; }
    }
    // ---------- Scroll State ----------
    let scrollY = 0;
    const SCROLL_SPEED = 60; // Pixels per wheel tick for smoother scrolling
    const MIN_SCROLL = 0;
    let maxScroll = 0;
    let isScrolling = false;

    // ---------- Rendering ----------
    const canvas=$('game'); const ctx=canvas.getContext('2d'); let W=0,H=0, cardW=96, cardH=134, gap=14, margin=26, topArea=160, overlapUp=26, overlapDown=32;

    function handleWheel(e) {
      e.preventDefault();
      // Use the browser's native smooth scrolling behavior
      const delta = e.deltaY * 0.5; // Reduce the delta for smoother scrolling
      scrollY = clamp(scrollY + delta, MIN_SCROLL, maxScroll);
      
      // Use requestAnimationFrame for smoother animation
      if (!isScrolling) {
        isScrolling = true;
        requestAnimationFrame(() => {
          draw();
          isScrolling = false;
        });
      }
    }

    function resize(){ 
      canvas.width=window.innerWidth; 
      canvas.height=window.innerHeight; 
      W=canvas.width; 
      H=canvas.height; 
      margin=0; 
      cardW=125; 
      cardH=cardW*1.4; 
      overlapUp=cardH/4; 
      overlapDown=cardH/4; 
      topArea=120; 
      // Position the first column at 10px from the left edge
      colX=c=>10 + c*(cardW+8); 
      overlapUp=Math.floor(cardH*0.24); 
      overlapDown=Math.floor(cardH*0.30); 
      
      // Calculate max scroll based on the tallest column with extra space at bottom
      maxScroll = Math.max(0, ...state.tableau.map(col => {
        const totalHeight = col.reduce((sum, card, i) => 
          sum + (i === 0 ? overlapDown : (col[i-1].faceUp ? overlapDown : overlapUp)), 0);
        // Add extra space (2x viewport height) to allow for more scrolling room
        return Math.max(0, (totalHeight + H) - (H - topArea - margin));
      }));
      // Ensure scroll position is within bounds
      scrollY = clamp(scrollY, MIN_SCROLL, maxScroll);
      
      draw(); 
    }
    
    // Add event listeners for smooth scrolling
    canvas.addEventListener('wheel', handleWheel, { passive: false });
    
    // Enable touch events for mobile
    let touchStartY = 0;
    canvas.addEventListener('touchstart', (e) => {
      touchStartY = e.touches[0].clientY;
    }, { passive: true });
    
    canvas.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1) {
        const touchY = e.touches[0].clientY;
        const delta = touchStartY - touchY;
        scrollY = clamp(scrollY + delta * 1.5, MIN_SCROLL, maxScroll);
        touchStartY = touchY;
        if (!isScrolling) {
          isScrolling = true;
          requestAnimationFrame(() => {
            draw();
            isScrolling = false;
          });
        }
        e.preventDefault();
      }
    }, { passive: false });
    window.addEventListener('resize', resize);

    let colX = (i) => margin + i * (cardW + gap);
    const pileY = () => margin + 20;

    function drawRounded(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

    // Background motif drawing function (kept but not used to avoid breaking existing code)
    // Background motif drawing function (commented out as it's not currently used)
    // function drawPeacockGlass(x, y, w, h) {
    //   const g = ctx.createLinearGradient(x, y, x + w, y + h);
    //   g.addColorStop(0, 'rgba(34,211,238,.12)');
    //   g.addColorStop(1, 'rgba(124,58,237,.12)');
    //   ctx.fillStyle = g;
    //   ctx.fillRect(x, y, w, h);
    //   
    //   ctx.globalAlpha = 0.18;
    //   ctx.strokeStyle = 'rgba(14,165,233,.6)';
    //   for (let i = 0; i < 8; i++) {
    //     ctx.beginPath();
    //     const cx = x + w / 2, cy = y + h / 2;
    //     const r = w * 0.5 * (1 - i / 8);
    //     ctx.ellipse(cx, cy, r, r * 0.55, 0, 0, Math.PI * 2);
    //     ctx.stroke();
    //   }
    //   ctx.globalAlpha = 1;
    // }

    function drawCard(x,y,card){ 
      const r=15; 
      ctx.save(); 
      // Shadow removed from text
      ctx.font = `bold ${Math.floor(cardW/5.5)}px Arial`;
      
      // Draw the card background
      drawRounded(x,y,cardW,cardH,r);
      
      if(card.faceUp) {
        // Draw face-up card
        ctx.fillStyle='#ffffff'; // White background for face-up cards
        ctx.fill();
        // Add subtle border
        ctx.strokeStyle='rgba(0,0,0,0.1)'; 
        ctx.lineWidth=1; 
        ctx.stroke();
        // Add subtle shadow inside the card
        const grad=ctx.createLinearGradient(x,y,x,y+cardH);
        grad.addColorStop(0,'rgba(0,0,0,.03)');
        grad.addColorStop(1,'rgba(0,0,0,.01)');
        ctx.fillStyle=grad;
        drawRounded(x,y,cardW,cardH,r);
        ctx.fill();
        
        // Draw rank and suit
        const rankStr = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'][card.rank-1];
        const isRed = RED.has(card.suit);
        const textColor = isRed ? '#cc0000' : '#000000';
        
        // Increased font sizes by 50%
        // Rank in top left
        ctx.font = `bold ${Math.floor(cardW*0.36)}px system-ui`;
        ctx.textBaseline = 'top';
        ctx.fillStyle = textColor;
        ctx.fillText(rankStr, x+10, y+8);
        
        // Suit in top right (moved from bottom right)
        ctx.font = `bold ${Math.floor(cardW*0.42)}px system-ui`;
        ctx.textBaseline = 'top';
        ctx.fillText(card.suit, x+cardW-Math.floor(cardW*0.42)-10, y+8);
      } else {
        // Draw face-down card
        ctx.fillStyle='#1a3a5f'; // Dark blue background for face-down cards
        ctx.fill();
        // Add subtle border
        ctx.strokeStyle='rgba(255,255,255,0.1)'; 
        ctx.lineWidth=1; 
        ctx.stroke();
        
        // Add subtle pattern to face-down cards
        ctx.save();
        ctx.globalAlpha = 0.1;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        const patternSize = 12;
        for (let py = y + patternSize; py < y + cardH; py += patternSize * 2) {
          ctx.beginPath();
          for (let px = x + (py % (patternSize * 2) === 0 ? 0 : patternSize); px < x + cardW; px += patternSize * 2) {
            ctx.moveTo(px, py);
            ctx.lineTo(px + patternSize, py + patternSize);
          }
          ctx.stroke();
        }
        ctx.restore();
      }
      ctx.restore(); 
    }

    function draw(){ 
      if(!ctx) return; 
      ctx.clearRect(0,0,W,H);
      
      // Apply scroll transform
      ctx.save();
      ctx.translate(0, -scrollY);
      
      // Stock visualization removed
      // Removed foundations display - now shown as a counter in the HUD
      // columns
      const y0=topArea; 
      for(let c=0;c<10;c++){ 
        const x=colX(c);
        const col = state.tableau[c];
        
        // Draw the cards in the column first
        let yy = y0;
        for(let i=0; i<col.length; i++){ 
          drawCard(x,yy,col[i]); 
          yy += col[i].faceUp ? overlapDown : overlapUp; 
        }
        
        // Only draw the empty column indicator if the column is truly empty
        if(col.length === 0) {
          // Draw the empty column background
          drawRounded(x,y0,cardW,cardH,12); 
          ctx.strokeStyle='rgba(255,255,255,.12)'; 
          ctx.stroke();
          
          // Draw the dashed yellow border for empty columns
          ctx.save(); 
          ctx.setLineDash([6,4]); 
          ctx.strokeStyle='rgba(245,158,11,.9)'; 
          ctx.lineWidth=3; 
          drawRounded(x-4,y0-4,cardW+8,cardH+8,14); 
          ctx.stroke(); 
          ctx.restore();
        }
        if(state.hint && state.hint.to===c){ ctx.save(); ctx.strokeStyle='rgba(20,184,166,.9)'; ctx.lineWidth=3; drawRounded(x-4,y0-4,cardW+8,cardH+8,14); ctx.stroke(); ctx.restore(); }
      }
      // drag ghost (not affected by scroll)
      ctx.restore(); // Restore transform for drag ghost
      
      // Draw column numbers (drawn after scroll restore to stay on top)
      ctx.save();
      ctx.font = 'bold 24px Arial';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for(let c = 0; c < 10; c++) {
        const x = colX(c) + cardW/2;
        const y = topArea - 15; // Moved down slightly (from -30 to -15)
        ctx.fillText(c + 1, x, y);
      }
      ctx.restore();
      if(drag.active){ 
        let yy=drag.y - drag.grabOffsetY; 
        for(const card of drag.stack){ 
          drawCard(drag.x - drag.grabOffsetX, yy, card); 
          yy += overlapDown; 
        } 
      }
      // confetti particles (not affected by scroll)
      if(confetti.length){ 
        for(const p of confetti){ 
          p.x+=p.vx; 
          p.y+=p.vy; 
          p.vy+=0.12; 
          p.life-=1; 
          ctx.save(); 
          ctx.globalAlpha=Math.max(0, p.life/80); 
          ctx.fillStyle=p.color; 
          ctx.translate(p.x,p.y); 
          ctx.rotate(p.rot+=(p.spin)); 
          ctx.fillRect(-4,-4,8,8); 
          ctx.restore(); 
        } 
        confetti = confetti.filter(p=>p.life>0); 
        requestAnimationFrame(draw); 
      }
    }

    // ---------- Input / Drag ----------
    const drag={active:false, fromCol:-1, startIndex:-1, stack:[], x:0,y:0, grabOffsetX:0, grabOffsetY:0};
    function colAt(px){ for(let c=0;c<10;c++){ const x=colX(c); if(px>=x && px<=x+cardW) return c; } return -1; }
    function rowAtInCol(py, col){ const y0=topArea; const colArr=state.tableau[col]; let yy=y0; for(let i=0;i<colArr.length;i++){ const yTop=yy, yBot=yy+(colArr[i].faceUp?overlapDown:overlapUp); if(py>=yTop && py<=yBot) return i; yy=yBot; } if(colArr.length) return colArr.length-1; return -1; }

    function onPointerDown(e){ 
      if(state.won) return; 
      AudioKit.resume(); 
      const rect=canvas.getBoundingClientRect(); 
      const px=e.clientX-rect.left, py=e.clientY-rect.top; 
      const col=colAt(px); 
      if(col<0) return; 
      const row=rowAtInCol(py,col); 
      if(row<0) return; 
      const column=state.tableau[col]; 
      const card=column[row]; 
      if(!card.faceUp){ 
        bounce(); 
        return; 
      }
      AudioKit.click(); // Play click sound when selecting a card
      // Validate same-suit descending tail from row
      for(let i=column.length-1;i>row;i--){ const a=column[i], b=column[i-1]; if(!(a.faceUp && b.faceUp && a.rank+1===b.rank && a.suit===b.suit)){ bounce(); flashMsg('Drag a same-suit descending tail'); return; } }
      drag.active=true; drag.fromCol=col; drag.startIndex=row; drag.stack=structuredClone(column.slice(row)); drag.x=px; drag.y=py; drag.grabOffsetX=clamp(px - colX(col), 0, cardW); drag.grabOffsetY=clamp(py - (topArea + row*overlapDown), 0, cardH); window.addEventListener('pointermove', onPointerMove); window.addEventListener('pointerup', onPointerUp);
    }
    function onPointerMove(e){ const r=canvas.getBoundingClientRect(); drag.x=e.clientX-r.left; drag.y=e.clientY-r.top; draw(); }
    function onPointerUp(e){ 
      window.removeEventListener('pointermove', onPointerMove); 
      window.removeEventListener('pointerup', onPointerUp); 
      if(!drag.active) return; 
      const r=canvas.getBoundingClientRect(); 
      const px=e.clientX-r.left; 
      const to=colAt(px); 
      if(to>=0){ 
        doMove(drag.fromCol, drag.startIndex, to);
        AudioKit.thud(); // Play thud sound when dropping cards
      } 
      drag.active=false; 
      draw(); 
    }
    canvas.addEventListener('pointerdown', onPointerDown);

    function bounce(){ canvas.animate([{transform:'translateX(0)'},{transform:'translateX(-4px)'},{transform:'translateX(4px)'},{transform:'translateX(0)'}],{duration:120}); AudioKit.blip(200,0.05,'square',0.04); }

    // ---------- Timer & UI ----------
    let lastTick=now(); function tick(){ const t=now(); if(state.running){ state.elapsedMs+=(t-lastTick);} lastTick=t; updateUI(); requestAnimationFrame(tick); }
    function fmtTime(ms){ const s=Math.floor(ms/1000); const m=(s/60)|0; const ss=(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; }
    function updateUI(){
      $('time').textContent=fmtTime(state.elapsedMs);
      $('moves').textContent=state.moves;
      $('score').textContent=state.score;
      $('sets-counter').textContent=state.foundations;
      $('deals').textContent=state.dealsRemaining;
      $('seedLabel').textContent=state.seed;
      
      const hasEmpty = state.tableau.some(c=>c.length===0);
      const isFinalDeal = state.dealsRemaining === 1 && state.stock.length > 0 && state.stock.length < 10;
      const enoughStock = state.stock.length >= 10 || isFinalDeal; // Allow final deal with < 10 cards
      const dealDisabled = hasEmpty || state.dealsRemaining<=0 || (!enoughStock && !isFinalDeal);
      
      $('dealBtn').disabled = dealDisabled;
      
      // Update button title based on state
      let title = 'Deal next row';
      if (state.dealsRemaining <= 0) {
        title = 'No deals left';
      } else if (hasEmpty) {
        title = 'Fill empty columns before dealing';
      } else if (isFinalDeal) {
        title = 'Deal final cards';
      } else if (state.stock.length < 10) {
        title = 'Not enough cards in stock';
      }
      $('dealBtn').title = title;
      
      // Update reason message
      const reasonEl = $('dealReason');
      if(dealDisabled && !isFinalDeal) {
        reasonEl.style.display='inline-block';
        reasonEl.textContent = state.dealsRemaining<=0 ? 'No deals left' : 
                             (hasEmpty ? 'Deal blocked: empty column(s)' : 'Deal blocked: not enough cards');
      } else {
        reasonEl.style.display='none';
      }
      $('undoBtn').disabled=state.history.length===0;
      $('redoBtn').disabled=state.redo.length===0;
      const diffSel = $('difficulty'); if(diffSel) diffSel.value = state.difficulty;
      document.title = state.won? '✅ Spider – Win!' : 'Spider Solitaire – Peacock';
    }
    function flashMsg(m){ state.message=m; const el=$('msg'); el.textContent=m; el.style.opacity=1; el.animate([{opacity:1},{opacity:0}],{duration:1600, fill:'forwards'}); }

    // ---------- Hints ----------
    function computeHint(){
      const hints = [];
      for(let from=0; from<10; from++) {
        const col = state.tableau[from];
        if(!col.length || !top(col).faceUp) continue;
        
        for(let start=0; start<col.length; start++) {
          if(!col[start].faceUp) continue;
          
          // Check if this is a valid run (sequence of same-suit descending cards)
          let ok = true;
          for(let i=col.length-1; i>start; i--) {
            const a = col[i], b = col[i-1];
            if(!(a.faceUp && b.faceUp && a.rank+1 === b.rank && a.suit === b.suit)) {
              ok = false;
              break;
            }
          }
          if(!ok) continue;
          
          const head = col[start];
          
          // Check all possible destination columns
          for(let to=0; to<10; to++) {
            if(to === from) continue;
            const destTop = top(state.tableau[to]);
            if(canDrop(head, destTop)) {
              let score = 0;
              const reasons = [];
              
              // Bonus for revealing a face-down card
              if(start > 0 && !col[start-1].faceUp) {
                score += 3;
                reasons.push('Reveals a hidden card');
              }
              
              // Bonus for building same-suit sequence
              if(destTop && destTop.suit === head.suit && destTop.rank === head.rank+1) {
                score += 2;
                reasons.push('Builds same-suit sequence');
              }
              
              // Bonus for creating an empty column
              if(col.length === start+1 && state.tableau[to].length === 0) {
                score += 2;
                reasons.push('Creates an empty column');
              }
              
              hints.push({
                from, start, to,
                score,
                cardCount: col.length - start,
                reasons: reasons.length ? reasons : ['Basic move'],
                headRank: head.rank,
                headSuit: head.suit
              });
            }
          }
        }
      }
      
      // Sort hints by score (highest first) and then by number of cards moved (fewer first)
      return hints.sort((a, b) => b.score - a.score || a.cardCount - b.cardCount);
    }
    
    function showHint(){
      const hints = computeHint();
      const hintModal = $('hintModal');
      const hintList = $('hintList');
      
      // Clear previous hints
      hintList.innerHTML = '';
      
      if(hints.length === 0) {
        hintList.innerHTML = '<div class="hint-item">No moves available</div>';
        hintModal.style.display = 'flex';
        return;
      }
      
      // Add each hint to the list
      hints.forEach((hint, index) => {
        const fromCol = hint.from + 1;
        const toCol = hint.to + 1;
        const cardCount = hint.cardCount > 1 ? ` (${hint.cardCount} cards)` : '';
        const rankNames = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const rankName = rankNames[hint.headRank - 1];
        
        const hintElement = document.createElement('div');
        hintElement.className = `hint-item ${index === 0 ? 'best' : ''}`;
        hintElement.innerHTML = `
          <div><b>${index + 1}.</b> Move from column ${fromCol} to ${toCol}${cardCount}</div>
          <div class="hint-details">
            Moves ${hint.headSuit}${rankName}${hint.cardCount > 1 ? ' + ' + (hint.cardCount - 1) + ' more' : ''}<br>
            ${hint.reasons.join(' • ')}
          </div>
        `;
        
        // Click handler to execute the move
        hintElement.onclick = () => {
          doMove(hint.from, hint.start, hint.to);
          hintModal.style.display = 'none';
        };
        
        hintList.appendChild(hintElement);
      });
      
      // Show the best hint visually on the board
      state.hint = hints[0];
      draw();
      
      // Show the modal
      hintModal.style.display = 'flex';
    }
    
    // Close hint modal when clicking the close button
    $('closeHint').onclick = () => {
      $('hintModal').style.display = 'none';
      state.hint = null;
      draw();
    };
    
    // Close hint modal when clicking outside the content
    $('hintModal').onclick = (e) => {
      if (e.target === $('hintModal')) {
        $('hintModal').style.display = 'none';
        state.hint = null;
        draw();
      }
    };

    // ========== Helper Functions ==========
    // checkTableauCompletion function has been consolidated into the game logic
    
    // randSeed function is defined elsewhere in the code

    // ---------- Verification ----------
    function verifyInventory(){
      // Build index of all cards by id across tableau, stock, foundations
      const loc = new Array(104).fill(null);
      const place = (card, where)=>{ if(loc[card.id]!==null) duplicates.push(card.id); loc[card.id]=where; counts.total++; rankCounts[card.rank] = (rankCounts[card.rank]||0)+1; suitCounts[card.suit] = (suitCounts[card.suit]||0)+1; };
      const duplicates=[]; const rankCounts={}; const suitCounts={}; const counts={total:0, tableau:0, stock:0, foundations:0};
      // tableau
      for(const col of state.tableau){ for(const c of col){ place(c,'T'); counts.tableau++; } }
      // stock
      for(const c of state.stock){ place(c,'S'); counts.stock++; }
      // foundations
      for(const c of state.foundationsCards){ place(c,'F'); counts.foundations++; }
      const missing=[]; for(let i=0;i<loc.length;i++){ if(loc[i]===null) missing.push(i); }
      const ok = duplicates.length===0 && missing.length===0 && counts.total===104 && counts.tableau+counts.stock+counts.foundations===104;
      flashMsg(ok? 'Deck OK ✓' : `Issues: dup=${duplicates.length} missing=${missing.length}`);
      return {ok, duplicates, missing, counts};
    }

    // ---------- Win modal ----------
    let confetti=[]; function burst(){ for(let i=0;i<180;i++){ confetti.push({ x: W/2, y: topArea+cardH/2, vx:(Math.random()*4-2), vy:(Math.random()*-5-2), rot:0, spin:(Math.random()*.2-.1), life: 80+(Math.random()*40|0), color:`hsl(${(Math.random()*360|0)},80%,60%)`}); } draw(); }
    function showWin(){ $('winTime').textContent=fmtTime(state.elapsedMs); $('winMoves').textContent=state.moves; $('winScore').textContent=state.score; $('winModal').style.display='grid'; burst(); }
    $('playAgain').onclick=()=>{ 
      $('winModal').style.display='none'; 
      newGame({
        difficulty: state.difficulty,
        includeAces: state.includeAces
      }); 
    };
    $('shareSeed').onclick=async()=>{ const url=new URL(location.href); url.searchParams.set('seed', state.seed); url.searchParams.set('difficulty', state.difficulty); try{ await navigator.clipboard.writeText(url.toString()); flashMsg('Link copied'); }catch{ flashMsg(url.toString()); } };

    // ---------- Controls ----------
    $('newBtn').onclick=()=> newGame({
      difficulty: state.difficulty,
      includeAces: $('includeAces').checked
    });
    $('replayBtn').onclick=()=> newGame({
      difficulty: state.difficulty, 
      seed: state.seed,
      includeAces: state.includeAces
    });
    $('dealBtn').onclick=()=> dealRow();
    $('undoBtn').onclick=()=> undo();
    $('redoBtn').onclick=()=> redo();
    $('hintBtn').onclick=()=> showHint();
    $('difficulty').onchange=(e)=> newGame({
      difficulty: e.target.value,
      includeAces: $('includeAces').checked
    });
    
    $('includeAces').onchange=(e)=> newGame({
      difficulty: state.difficulty,
      includeAces: e.target.checked
    });
    
    // Stats modal functionality
    function showStats() {
      console.log('Showing stats...');
      const statsModal = $('statsModal');
      const overallStats = $('overallStats');
      const recentGames = $('recentGames');
      
      if (!statsModal || !overallStats || !recentGames) {
        console.error('Could not find required elements:', { statsModal, overallStats, recentGames });
        return;
      }
      
      const stats = getGameStats();
      
      // Update overall stats
      if (overallStats) {
        const totalGames = stats.stats?.totalGames || 0;
        const wins = stats.stats?.wins || 0;
        const winRate = totalGames > 0 ? Math.round((wins / totalGames) * 100) : 0;
        
        overallStats.innerHTML = `
          <div>Total Games: ${totalGames}</div>
          <div>Wins: ${wins} (${winRate}%)</div>
          <div>Current Streak: ${stats.stats?.currentStreak || 0}</div>
          <div>Best Streak: ${stats.stats?.bestStreak || 0}</div>
          <div>Best Time: ${stats.stats?.bestTime ? fmtTime(stats.stats.bestTime) : 'N/A'}</div>
          <div>Best Moves: ${stats.stats?.bestMoves || 'N/A'}</div>
          <div>Best Score: ${stats.stats?.bestScore || 0}</div>
        `;
      }
      
      // Update recent games
      if (recentGames) {
        recentGames.innerHTML = '';
        const recent = Object.entries(stats.games || {})
          .sort(([,a], [,b]) => (b.endTime || 0) - (a.endTime || 0))
          .slice(0, 5);
        
        if (recent.length === 0) {
          recentGames.innerHTML = '<div>No recent games</div>';
        } else {
          recent.forEach(([key, game]) => {
            if (!game) return;
            const gameEl = document.createElement('div');
            gameEl.className = 'recent-game';
            gameEl.innerHTML = `
              <div>${game.endTime ? new Date(game.endTime).toLocaleString() : 'Unknown time'}</div>
              <div>${game.difficulty || 'Unknown'} - ${game.outcome === 'win' ? '🏆' : '❌'}</div>
              <div>${game.duration ? fmtTime(game.duration) : 'N/A'} - ${game.moves || 0} moves - Score: ${game.score || 0}</div>
            `;
            recentGames.appendChild(gameEl);
          });
        }
      }
      
      // Show the modal
      statsModal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }
    
    $('setSeedBtn').onclick=()=>{ 
      const v=$('seedInput').value.trim(); 
      if(v){ 
        const u=new URL(location.href); 
        u.searchParams.set('seed', v); 
        u.searchParams.set('difficulty', state.difficulty);
        history.replaceState({},'',u); 
        newGame({
          difficulty: state.difficulty, 
          seed: v,
          includeAces: $('includeAces').checked
        }); 
      } 
    };
    // Initialize mute button state
    $('muteBtn').textContent = AudioKit.isMuted() ? '🔇' : '🔊';
    $('muteBtn').onclick = () => {
      const v = !AudioKit.isMuted();
      AudioKit.setMuted(v);
      // Play feedback sound when toggling mute
      if (!v) AudioKit.click();
    };
    $('verifyBtn').onclick=()=> verifyInventory();
    window.addEventListener('keydown', (e)=>{
      if(e.repeat) return;
      const key = e.key.toLowerCase();
      if(key === 'n') $('newBtn').click();
      else if(key === 'd') $('dealBtn').click();
      else if(key === 'u') $('undoBtn').click();
      else if(key === 'r') $('redoBtn').click();
      else if(key === 'h') $('hintBtn').click();
      else if(key === 'v') $('verifyBtn').click();
    });

    // Initialize stats button and modal
    function initStats() {
      // Set up stats button click handler
      const showStatsBtn = $('showStats');
      const closeBtn = $('closeStats');
      const statsModal = $('statsModal');
      
      if (showStatsBtn) {
        showStatsBtn.onclick = showStats;
        console.log('Stats button initialized');
      } else {
        console.error('Could not find showStats button');
      }
      
      if (closeBtn && statsModal) {
        closeBtn.onclick = () => {
          statsModal.style.display = 'none';
          document.body.style.overflow = 'auto';
        };
        
        // Close when clicking outside the modal content
        statsModal.onclick = (e) => {
          if (e.target === statsModal) {
            statsModal.style.display = 'none';
            document.body.style.overflow = 'auto';
          }
        };
      }
    }

    // ---------- Boot ----------
    function initFromURL(){ const url=new URL(location.href); const seed=url.searchParams.get('seed')||randSeed(); const diff=url.searchParams.get('difficulty')||'1-suit'; return {seed,difficulty:diff}; }
    resize(); const init=initFromURL(); if(!loadGame()){ newGame(init); } 
    initStats(); // Initialize stats button and modal
    requestAnimationFrame(tick);
  </script>
</body>
</html>

